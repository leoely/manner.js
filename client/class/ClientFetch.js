Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;class ClientFetch{constructor(){this.filters={},this.hasTimeout=!0,this.idx=0,this.abortControllers=[]}setHasTimeout(t){if("boolean"!=typeof t)throw new Error("[Error] The parameter has a timeout and needs to be a boolean type.");this.hasTimeout=t}addFilter(t,e){if(!(Number.isInteger(t)&&0<=t))throw new Error("[Error] The parameter status code should be a positive integer type.");if("function"!=typeof e)throw new Error("[Error] The parameter callback should be4 of function type.");var r=this.filters;if(void 0!==r[t])throw new Error("[Error] The current status code has been bound.");r[t]=e}renew(){var t=this.abortControllers;t.forEach(t=>{void 0!==t&&t.abort()}),this.idx=0,this.abortControllers=[]}async fetch(t,e){var r,o=new AbortController,a=this.idx,i=(this.abortControllers[a]=o,this.idx+=1,this).hasTimeout;let s;if(!0===i)try{s=void 0!==e?(r=e.ownSignals,Array.isArray(r)?await fetch(t,{signal:AbortSignal.any([AbortSignal.timeout(9e3),o.signal,...r]),...e}):await fetch(t,{signal:AbortSignal.any([AbortSignal.timeout(9e3),o.signal]),...e})):await fetch(t,{signal:AbortSignal.any([AbortSignal.timeout(9e3),o.signal])})}catch(t){i=t.name;switch(i){case"AbortError":case"TimeoutError":var n=this.filters;await n[512](s);break;default:throw new Error("[Error] Unexpected exception occurred.")}}else s=void 0!==e&&"object"==typeof e?await fetch(t,{...e,headers:{"Has-Timeout":"false"}}):await fetch(t,{headers:{"Has-Timeout":"false"}});if(void 0!==s){if(s.ok)return this.abortControllers[a]=void 0,s;throw r=s.status,o=this.filters,await o[r](s),new Error("[Error] Receive an exception from the server.")}}}var _default=exports.default=ClientFetch;